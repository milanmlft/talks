---
title: "Go: Your New Go-To DevOps Language"
subtitle: ARC DevOps Hour
date: 2025-12-11
author: "Milan Malfait"
format:
  revealjs:
    slide-number: true
    toc: false
execute:
  echo: true
  eval: false
---

## Introduction

:::: {.columns}

::: {.column width="30%"}
![](https://raw.githubusercontent.com/egonelbre/gophers/63b1f5a9f334f9e23735c6e09ac003479ffe5df5/vector/adventure/hiking.svg)
:::

::: {.column width="70%"}

- My Go journey
  - Fiddling around with it and used it for Advent of Code 2024
  - Joined the ARC TRE team January 2025

- What we'll cover today:
  - Go's unique characteristics
  - Why it's ideal for DevOps
  - Real-world examples
    :::

::::

---

## What Makes Go Different {.smaller}

:::: {.columns}

::: {.column}

- Created at Google (2009) as a modern simple alternative to C
- Core philosophy: simplicity, readability, and pragmatism
- Key features overview: compiled, statically typed, garbage collected, built-in concurrency
- The "boring is good" principle - stability over novelty
- Compilation speed: Go compiles so fast it feels interpreted
  :::

::: {.column}

![](https://raw.githubusercontent.com/golang-samples/gopher-vector/9fe99fbf17b019125bf649f8a921882b54e151a6/gopher.svg)

:::

::::

---

## Why Go?

- Designed for modern software engineering challenges
  - Performance
  - Scalability
  - Security
  - Reliability

- Lean syntax
- Strong standard library
- Built-in tools

![](https://raw.githubusercontent.com/keygx/Go-gopher-Vector/fe01b920482f9ab2c6ec7d1928c3c617341e3841/svg/gopher02c.svg){.absolute top=200 right=100 width="300"}

---

## Go's Minimal Syntax

- Only 25 keywords (Python: 35, Java: 68, C++23: 92)
- Strongly idiomatic - one way to do things
- No classes, no inheritance - favour composition
- Explicit error handling - no exceptions
- Fast compilation: feels like an interpreted language

---

### A complete web server in 15 lines

```{.go}
package main

import (
    "fmt"
    "net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, %s!", r.URL.Path[1:])
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

---

## All You Need Is STD

Go's standard library includes everything you need[^1]:

- `os`, `io`, `fmt`
- Logging: `log`, `log/slog`
- Networking: `net/http`
- Databases: `database/sql`
- Data: `encoding/json`, `encoding/xml`, `encoding/csv`
- ... and much more

::: {.notes}
Bonus: the standard library is actually readable and an excellent resource for learning Go (take that, C++)
:::

[^1]: until it doesn't, in which case Go still has an excellent package ecosystem.

---

## The joy of having built-in tools

```bash
# Formatting
go fmt

# Testing
go test

# Compile & execute
go run

# Dependency management
go install
go get

# Docs generator
go doc
```

---

## The joy of having built-in tools

![](figures/python-tooling-formatters.png){fig-align="center"}

---

## What About Performance?

> Go has excellent performance right out of the box. By design, there are no
> knobs or levers that you can use to squeeze more performance out of Go
>
> -- _[Steve Francia (Go Team)](https://spf13.com/p/rust-vs-go-better-together)_

---

## What About Performance? {.smaller}

> Go has excellent performance right out of the box. By design, there are no
> knobs or levers that you can use to squeeze more performance out of Go
>
> -- _[Steve Francia (Go Team)](https://spf13.com/p/rust-vs-go-better-together)_

![](figures/speed-comparison.png){fig-align="center" fig-alt="Speed comparison of programming languages"}

---

## Go's DevOps Superpowers

:::: {.columns}

:::{.column width="30%"}
![](https://raw.githubusercontent.com/egonelbre/gophers/63b1f5a9f334f9e23735c6e09ac003479ffe5df5/vector/superhero/standing.svg)
:::

:::{.column width="70%"}

- Fast build times & cross-compilation
- Small static binaries
- Low memory footprint and garbage collection
- Efficient concurrency
- Lends itself well to microservices architecture
  :::

::::

---

## Go Powers Your DevOps Stack

- **Container orchestration**: Docker, Kubernetes, containerd
- **Infrastructure**: Terraform, Packer, Consul, Vault
- **Monitoring**: Prometheus, Grafana, Telegraf
- **CLI tools**: GitHub CLI, kubectl, helm
- **Cloud**: Many AWS/GCP/Azure tools

---

## Go Powers Your DevOps Stack

Why did they choose Go?

- Fast builds for rapid iteration
- Easy deployment (single binary)
- Excellent networking libraries
- Natural fit for distributed systems

---

## Concurrency with Goroutines

![](figures/gopher-goroutines.jpg){fig-align="center"}

---

## Concurrency with Goroutines

- Goroutines: lightweight threads managed by Go runtime
- Simple syntax: just add `go` before a function call
- Channels: safe communication between goroutines
- Perfect for DevOps tasks:
  - Parallel API calls to multiple services
  - Concurrent log processing
  - Non-blocking I/O operations

---

## Goroutines in Action {auto-animate=true}

A non-concurrent example

```{.go}
func checkHealth(url string, results string)

func main() {
    services := []string{"http://api1.com", "http://api2.com", "http://api3.com"}
    results := make(string, len(services))

    for _, service := range services {
        checkHealth(service, results)
    }

    for range services {
        fmt.Println(results)
    }
}
```

---

## Goroutines in Action {auto-animate=true}

Making it concurrent

```{.go}
func checkHealth(url string, results chan<- string)

func main() {
    services := []string{"http://api1.com", "http://api2.com", "http://api3.com"}
    results := make(chan string, len(services))

    for _, service := range services {
        go checkHealth(service, results)
    }

    for range services {
        fmt.Println(<-results)
    }
}
```

---

## Goroutines in Action

Making it concurrent

```{.go code-line-numbers="1,5,8,12"}
func checkHealth(url string, results chan<- string)

func main() {
    services := []string{"http://api1.com", "http://api2.com", "http://api3.com"}
    results := make(chan string, len(services))

    for _, service := range services {
        go checkHealth(service, results)
    }

    for range services {
        fmt.Println(<-results)
    }
}
```

---

## Every Go Program is a Goroutine

</br>

```{.go filename="main.go"}
func main() {
    panic("AAAAHHH!")
}
```

---

## Every Go Program is a Goroutine

</br>

```{.go filename="main.go"}
func main() {
    panic("AAAAHHH!")
}
```

</br>

```{.bash code-line-numbers="4"}
$ go run ./main.go
panic: AAAAHHH!

goroutine 1 [running]:
main.main()
	/Users/milan/talks/2025-12-07-DevOpsHour-Go/examples/panic/main.go:4 +0x2c
exit status 2
```

---

## Error Handling: Explicit is Better

```go
data, err := ioutil.ReadFile("config.yaml")
if err != nil {
    return fmt.Errorf("failed to read config: %w", err)
}
```

- No hidden control flow (no exceptions)
- Errors are values
- Forces you to think about failure cases
- `defer` for cleanup

---

## Things to Go Away With (Takeaways)

- **Start simple**: Go's standard library covers most DevOps needs
- **Embrace concurrency**: Goroutines make parallel tasks trivial
- **Static binaries = deployment joy**: No dependency hell
- **Performance by default**: No optimization gymnastics needed
- **DevOps tooling loves Go**: Docker, Kubernetes, Terraform, Prometheus...

**Try it yourself**: <https://go.dev/tour/>

---

## Further Reading

**Official Resources:**

- Go Tour: <https://go.dev/tour/>
- Effective Go: <https://go.dev/doc/effective_go>
- Go by Example: <https://gobyexample.com/>

**Books:**

- "The Go Programming Language" (Donovan & Kernighan)
- "Learning Go" (Jon Bodner)

**DevOps-Specific:**

- "Cloud Native Go" (M.-Leander Reimer)
