---
title: "Go: Your New Go-To DevOps Language"
subtitle: ARC DevOps Hour
date: 2025-12-11
author: "Milan Malfait"
format:
  revealjs:
    slide-number: true
    toc: false
execute:
  echo: true
  eval: false
---

## Introduction

- Who am I?
  - Background with Go
  - Why I'm excited to share this with you

- What we'll cover today:
  - Go's unique characteristics
  - Why it's ideal for DevOps
  - Real-world examples
  - Practical demonstrations

---

## What Makes Go Different

- Created at Google (2009) as a modern simple alternative to C
- Core philosophy: simplicity, readability, and pragmatism
- Key features overview: compiled, statically typed, garbage collected, built-in concurrency
- The "boring is good" principle - stability over novelty
- Compilation speed: Go compiles so fast it feels interpreted

---

## Why Go?

- Designed for modern software engineering challenges
  - Performance
  - Scalability
  - Security
  - Reliability

- Lean syntax &rarr; Easy to learn and use
- Strong standard library
- Built-in tools

---

## Go's Minimal Syntax

- Only 25 keywords (Python: 35, Java: 50+)
- One way to do things (vs. Python's "many ways")
- No classes, no inheritance, no generics (until Go 1.18)
- Explicit error handling - no exceptions
- Fast compilation: feels like an interpreted language

**Example: A complete web server in ~15 lines**

## All You Need Is STD

Go's standard library includes everything you need[^1]:

- `os`, `io`, `fmt`
- Logging: `log`, `log/slog`
- Networking: `net/http`
- Databases: `database/sql`
- Data: `encoding/json`, `encoding/xml`, `encoding/csv`
- ... and much more

<!--Bonus: the standard library is actually readable and an excellent resource for learning Go (take that, C++)-->

[^1]:
    until it doesn't, in which case Go still has an excellent package
    ecosystem. In any case, you should always start with just the standard library.

---

## The joy of having built-in tools

<!--TODO: contrast with Python, use python-tooling website screenshot-->

```bash
# Formatting
go fmt

# Testing
go test

# Compile & execute
go run

# Dependency management
go install
go get

# Docs generator
go doc
```

---

## The joy of having built-in tools

![](figures/python-tooling-formatters.png){fig-align="center"}

---

## What About Performance?

::: {style="font-size: 50%;"}

> Go has excellent performance right out of the box. By design, there are no
> knobs or levers that you can use to squeeze more performance out of Go
>
> -- _[Steve Francia (Go Team)](https://spf13.com/p/rust-vs-go-better-together)_

:::

---

## What About Performance?

::: {style="font-size: 50%;"}

> Go has excellent performance right out of the box. By design, there are no
> knobs or levers that you can use to squeeze more performance out of Go
>
> -- _[Steve Francia (Go Team)](https://spf13.com/p/rust-vs-go-better-together)_

:::

![](figures/speed-comparison.png){fig-align="center" fig-alt="Speed comparison of programming languages"}

---

## Go's DevOps Superpowers

- Fast build times & cross-compilation
- Small static binaries
- Low memory footprint and garbage collection
- Efficient concurrency
- Lends itself very well to microservices architecture

---

## Concurrency with Goroutines

![](figures/gopher-goroutines.jpg){fig-align="center"}

---

## Concurrency with Goroutines

- Goroutines: lightweight threads managed by Go runtime
- Simple syntax: just add `go` before a function call
- Channels: safe communication between goroutines
- Perfect for DevOps tasks:
  - Parallel API calls to multiple services
  - Concurrent log processing
  - Non-blocking I/O operations

---

## Goroutines in Action {auto-animate=true}

A non-concurrent example

```{.go}
func checkHealth(url string, results string)

func main() {
    services := []string{"http://api1.com", "http://api2.com", "http://api3.com"}
    results := make(string, len(services))

    for _, service := range services {
        checkHealth(service, results)
    }

    for range services {
        fmt.Println(results)
    }
}
```

---

## Goroutines in Action {auto-animate=true}

Making it concurrent

```{.go}
func checkHealth(url string, results chan<- string)

func main() {
    services := []string{"http://api1.com", "http://api2.com", "http://api3.com"}
    results := make(chan string, len(services))

    for _, service := range services {
        go checkHealth(service, results)
    }

    for range services {
        fmt.Println(<-results)
    }
}
```

---

## Goroutines in Action

Making it concurrent

```{.go code-line-numbers="1,5,8,12"}
func checkHealth(url string, results chan<- string)

func main() {
    services := []string{"http://api1.com", "http://api2.com", "http://api3.com"}
    results := make(chan string, len(services))

    for _, service := range services {
        go checkHealth(service, results)
    }

    for range services {
        fmt.Println(<-results)
    }
}
```

---

## Every Go Program is a Goroutine

</br>

```{.go filename="main.go"}
func main() {
    panic("AAAAHHH!")
}
```

---

## Every Go Program is a Goroutine

</br>

```{.go filename="main.go"}
func main() {
    panic("AAAAHHH!")
}
```

</br>

```{.bash code-line-numbers="4"}
$ go run ./main.go
panic: AAAAHHH!

goroutine 1 [running]:
main.main()
	/Users/milan/talks/2025-12-07-DevOpsHour-Go/examples/panic/main.go:4 +0x2c
exit status 2
```

---

## Things to Go Away With (Takeaways)

- **Start simple**: Go's standard library covers most DevOps needs
- **Embrace concurrency**: Goroutines make parallel tasks trivial
- **Static binaries = deployment joy**: No dependency hell
- **Performance by default**: No optimization gymnastics needed
- **DevOps tooling loves Go**: Docker, Kubernetes, Terraform, Prometheus...

**Try it yourself**: <https://go.dev/tour/>

---

## Further Reading

**Official Resources:**

- Go Tour: <https://go.dev/tour/>
- Effective Go: <https://go.dev/doc/effective_go>
- Go by Example: <https://gobyexample.com/>

**Books:**

- "The Go Programming Language" (Donovan & Kernighan)
- "Learning Go" (Jon Bodner)

**DevOps-Specific:**

- "Cloud Native Go" (M.-Leander Reimer)
